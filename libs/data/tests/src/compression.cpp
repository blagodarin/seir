// This file is part of Seir.
// Copyright (C) Sergei Blagodarin.
// SPDX-License-Identifier: Apache-2.0

#include <seir_data/compression.hpp>

#include <algorithm>
#include <iterator>
#include <vector>

#include <doctest/doctest.h>

#if SEIR_COMPRESSION_ZLIB || SEIR_COMPRESSION_ZSTD
TEST_CASE("Compression")
{
	// The generated byte sequence is [00 00 00 00 01 01 01 01 ... ff ff ff ff 00 00 00 00 ... ff ff ff ff].
	// It should be compressible even by the worst practical compression algorithms (e. g. RLE).
	std::vector<std::byte> original;
	std::generate_n(std::back_inserter(original), 4 * 256 * 2, [i = -1]() mutable { return static_cast<std::byte>((i += 1) / 4); });
	const auto checkCompression = [&original](seir::Compression compression) {
		std::vector<std::vector<std::byte>> compressed;
		{
			const auto compressor = seir::Compressor::create(compression);
			REQUIRE(compressor);
			const auto compressNext = [&original, compression, &compressor](seir::CompressionLevel level, bool useMaxCapacity) {
				REQUIRE(compressor->prepare(level));
				auto dstCapacity = compressor->maxCompressedSize(original.size());
				REQUIRE(dstCapacity > 0);
				std::vector<std::byte> result(dstCapacity);
				if constexpr (sizeof(size_t) > sizeof(uint32_t))
					if (compression == seir::Compression::Zlib)
						CHECK(compressor->compress(result.data(), dstCapacity, original.data(), size_t{ std::numeric_limits<uint32_t>::max() } + 1) == 0);
				if (useMaxCapacity)
				{
					// Zstd does something weird if requested to compress into a buffer of SIZE_MAX bytes,
					// but since its API exposes size_t, this is not our problem.
					if (compression != seir::Compression::Zstd)
						dstCapacity = std::numeric_limits<size_t>::max();
				}
				const auto size = compressor->compress(result.data(), dstCapacity, original.data(), original.size());
				REQUIRE(size > 0);
				CHECK(size < original.size());
				result.resize(size);
				return result;
			};
			{
				INFO("CompressionLevel::BestSpeed");
				compressed.emplace_back(compressNext(seir::CompressionLevel::BestSpeed, false));
				MESSAGE("Compressed ", original.size(), " bytes into ", compressed.back().size(), " bytes");
				CHECK(compressNext(seir::CompressionLevel::BestSpeed, true) == compressed.back());
			}
			{
				INFO("CompressionLevel::BestCompression");
				compressed.emplace_back(compressNext(seir::CompressionLevel::BestCompression, false));
				MESSAGE("Compressed ", original.size(), " bytes into ", compressed.back().size(), " bytes");
				CHECK(compressNext(seir::CompressionLevel::BestCompression, true) == compressed.back());
			}
		}
		const auto decompressor = seir::Decompressor::create(compression);
		REQUIRE(decompressor);
		std::vector<std::byte> decompressed(original.size());
		for (size_t i = 0; i < compressed.size(); ++i)
		{
			INFO("compressed[", i, "]");
			std::fill(decompressed.begin(), decompressed.end(), std::byte{});
			CHECK_FALSE(decompressor->decompress(decompressed.data(), decompressed.size(), compressed[i].data(), compressed[i].size() / 2));
			CHECK(decompressor->decompress(decompressed.data(), decompressed.size(), compressed[i].data(), compressed[i].size()));
			CHECK(decompressed == original);
			if (compression != seir::Compression::Zstd)
			{
				// Zstd does something weird if requested to decompress into a buffer of SIZE_MAX bytes,
				// but since its API exposes size_t, this is not our problem.
				std::fill(decompressed.begin(), decompressed.end(), std::byte{});
				CHECK(decompressor->decompress(decompressed.data(), std::numeric_limits<size_t>::max(), compressed[i].data(), compressed[i].size()));
			}
			if constexpr (sizeof(size_t) > sizeof(uint32_t))
				if (compression == seir::Compression::Zlib)
					CHECK_FALSE(decompressor->decompress(decompressed.data(), decompressed.size(), compressed[i].data(), size_t{ std::numeric_limits<uint32_t>::max() } + 1));
		}
	};
#	if SEIR_COMPRESSION_ZLIB
	SUBCASE("Compression::Zlib")
	{
		checkCompression(seir::Compression::Zlib);
	}
#	endif
#	if SEIR_COMPRESSION_ZSTD
	SUBCASE("Compression::Zstd")
	{
		checkCompression(seir::Compression::Zstd);
	}
#	endif
}
#endif

TEST_CASE("Compression::None")
{
	CHECK_FALSE(static_cast<bool>(seir::Compressor::create(seir::Compression::None)));
	CHECK_FALSE(static_cast<bool>(seir::Decompressor::create(seir::Compression::None)));
}
